<!DOCTYPE html>
<html>
<head>
    <title>4c1d</title>
    <style>
        /* Add these new styles */
        .header-title {
            position: relative;
            cursor: pointer;
            user-select: none;
        }
        .instructions-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #222;
            padding: 10px;
            width: 300px;
            z-index: 1;
        }
        .header-title.expanded .instructions-dropdown {
            display: block;
        }
        .header-title.expanded::before {
            content: '▾';
        }
        .header-title::before {
            content: '▸';
            margin-right: 4px;
        }

        /* Existing styles remain completely unchanged */
        body { margin: 40px; font-family: Arial, sans-serif; background: #ffffff; }
        form { display: flex; gap: 20px; align-items: center; margin-bottom: 40px; }
        .input-group { display: flex; align-items: center; gap: 8px; }
        #reverseBtn { writing-mode: vertical-lr; transform: rotate(180deg); background: none; border: none; color: #000; padding: 0; cursor: pointer; font-size: 12px; letter-spacing: 0px; margin-right: -4px; }
        input { width: 66px; padding: 12px; border: 1px solid #222; font-size: 16px; }
        button[type="submit"] { padding: 12px 20px; background: #222; color: white; border: none; font-size: 16px; cursor: pointer; }
        .results { margin: 80px 20px 40px 20px; }
        .pattern { margin: 25px 0; }
        h3 { margin: 0 0 10px 0; font-size: 1.4em; }
    </style>
</head>
<body>
    <form onsubmit="return searchWords(event)">
        <div class="input-group">
            <button type="button" id="reverseBtn" onclick="reversePattern()">reverse</button>
            <input type="text" id="patterns">
        </div>
        <button type="submit">search</button>
        <div class="header-title" onclick="toggleInstructions()">substring concordance
    <div class="instructions-dropdown">
        <div style="padding: 8px;">
            <h4 style="margin: 0 0 10px 0; color: #444;"></h4>
            <p style="margin: 0 0 12px 0;">look for nested palindromes in words!<br>
            like "<em>eve</em>" in "never" or "<em>ece</em>" in "piece". <br>

            </ul>
        </div>
    </div>
</div>
    </form>
    <div id="results"></div>

    <script src="words.js"></script>
    
    <script>
    function toggleInstructions() {
        const title = document.querySelector('.header-title');
        title.classList.toggle('expanded');
    }
    // Function to reverse pattern
    function reversePattern() {
        const input = document.getElementById('patterns');
        const patterns = input.value.split(',').map(p => p.trim());
        
        const reversedPatterns = patterns.map(pattern => {
            const parenthesesCount = (pattern.match(/[()]/g) || []).length;
            
            if (parenthesesCount === 2) {
                return '(' + pattern.slice(1, -1).split('').reverse().join('') + ')';
            }
            else if (pattern.startsWith('(')) {
                return pattern.slice(1).split('').reverse().join('') + ')';
            }
            else if (pattern.endsWith(')')) {
                return '(' + pattern.slice(0, -1).split('').reverse().join('');
            }
            else {
                return pattern.split('').reverse().join('');
            }
        });
        
        input.value = reversedPatterns.join(', ');
        searchWords(new Event('submit'));
    }

    // Search function (unchanged)
   function searchWords(event) {
    event.preventDefault();
    const input = document.getElementById('patterns');
    const patterns = input.value
        .split(',')
        .map(p => p.trim())
        .filter(p => p.length > 0);

    const results = {};
    
    window.wordList.forEach(word => {
        const rawWord = word;
        const lowerWord = rawWord.toLowerCase();
        
        patterns.forEach(pattern => {
            let isMatch = false;
            let targetPattern = pattern;

            if (pattern.startsWith('(') && pattern.endsWith(')')) {
                // Parentheses handling - exact length match
                targetPattern = pattern.slice(1, -1).toLowerCase();
                
                if (/^[a-z]\*+$/i.test(targetPattern)) {
                    const letter = targetPattern[0];
                    const length = targetPattern.length;
                    const regexStr = `^${letter}[a-z]{${length - 1}}$`;
                    const regex = new RegExp(regexStr);
                    isMatch = regex.test(lowerWord);
                }
                else if (/^\*+[a-z]$/i.test(targetPattern)) {
                    const letter = targetPattern.slice(-1);
                    const length = targetPattern.length;
                    const regexStr = `^[a-z]{${length - 1}}${letter}$`;
                    const regex = new RegExp(regexStr);
                    isMatch = regex.test(lowerWord);
                }
                else if (/^\*+$/.test(targetPattern)) {
                    isMatch = lowerWord.length === targetPattern.length;
                }
                else {
                    if (targetPattern.includes('*')) {
                        const regexStr = `^${targetPattern.replace(/\*/g, '[a-z]')}$`;
                        const regex = new RegExp(regexStr);
                        isMatch = regex.test(lowerWord);
                    } else {
                        isMatch = lowerWord === targetPattern;
                    }
                }
            } 
            else if (pattern.startsWith('(*')) {
                // Handle prefix wildcards
                const afterPrefix = pattern.slice(2);
                const regexStr = '^' + afterPrefix.replace(/\*/g, '[a-z]').toLowerCase();
                const regex = new RegExp(regexStr);
                isMatch = regex.test(lowerWord);
            }
            else if (pattern.endsWith('*)')) {
                // Handle suffix wildcards
                const beforeSuffix = pattern.slice(0, -2);
                const regexStr = beforeSuffix.replace(/\*/g, '[a-z]').toLowerCase() + '$';
                const regex = new RegExp(regexStr);
                isMatch = regex.test(lowerWord);
            }
            else if (pattern.includes('*')) {
                // Changed to substring match without ^ and $
                const regexStr = pattern.toLowerCase().replace(/\*/g, '[a-z]');
                const regex = new RegExp(regexStr);
                isMatch = regex.test(lowerWord);
            }
            else {
                isMatch = lowerWord.includes(pattern.toLowerCase());
            }

            if (isMatch) {
                if (!results[pattern]) results[pattern] = [];
                results[pattern].push(rawWord);
            }
        });
    });

    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '';
    
    Object.entries(results).forEach(([pattern, words]) => {
        const html = `
        <div class="pattern">
            <h3>"${pattern}" (${words.length})</h3>
            <div>${words.join(', ')}</div>
        </div>`;
        resultsDiv.innerHTML += html;
    });
    
    input.blur();
    return false;
}
    </script>
</body>
</html>